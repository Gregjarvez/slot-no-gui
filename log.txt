class <ENTRY>   max stake default: $10   View: new View: update.   accumulated total wins   balance: {    start: 1000    left: start - lose amount   }   winLines: [      [], [], [], [], [], []      make object with color for display   ]   generate random numbers      type arrays 3 * 3   generate win lines      interface [0,1,1]   generate symbol on win lines      interface ['cherry', 'knife', 'gun']   compose all     interface Object       grid: [          [],[],[]       ]       winLines: [           [], [], []       ]       *rtp: number,       balance: number   updateMethod: () => {      observers.update(Object);   }   exits : reset game params and exit;   console.clear()   start: ==> render initial state   spin: ===> generate randoms, winlines , compose all and update   Class random number generator::    class RNG      config {object: min, max, howmany}      implements shuffle.         fisher Yates shuffle algorithm for unbias shuffle.         pseudo    function shuffle(array) {      var m = array.length, t, i;      // While there remain elements to shuffle…      while (m) {        // Pick a remaining element…        i = Math.floor(Math.random() * m--);        // And swap it with the current element.        t = array[m];        array[m] = array[i];        array[i] = t;      }      return array;    }   Class View    update.      use console.table ==> grid      color winLine if wins      console.log(win if win)      console.log(lose if lose)      expose show options api.      shouldComponentUpdate    ['bell', 'orange', 'prune', 'orange', 'seven']    ['prune', 'orange', 'seven', 'cherry', 'bar']    ['orange', 'bell', 'orange', 'prune', 'orange']   this.state = this.updateState({      grid: grid,      win: results.winState,      payout: payout || 0,          accumulatedWin: this.state.accumulatedWin += payout,          balance: results.winState ?                   this.state.balance - this.state.stake :                   this.state.balance + payout        });        // this.notify(this.state);        var results = this.payOut(winStats.filter(Boolean)); /* ? */              var payout = (                           this.symbols[results.symbol].value * 3                           ) * this.coinValue;use compositionpoints to decimalplacesbreak this pattern down.lose valueswin linestake shuffle out